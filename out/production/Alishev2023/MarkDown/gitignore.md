# git reset --hard HEAD~2 (означает удалить два последних коммита в указанной ветке)
git reset --hard HEAD~2 
# удаляем из индекса файл
git rm  --cached hexlet.txt
# записываем файл .gitignore
cat << EOF > .gitignore
любой текст в несколько строк строка 1
любой текст в несколько строк строка 2
любой текст в несколько строк строка 3
EOF
# ДОписываем файл .gitignore
cat << EOF >> .gitignore
любой текст в несколько строк строка 4
любой текст в несколько строк строка 5
любой текст в несколько строк строка 6
EOF


# А что если мы не знаем коммита, но нам интересно, кто последним менял конкретную строчку в файле?
git blame INFO.md

# кто в каком коммите что менял (авторство)
git log -- blame todo.md


#########################
# Команда git grep ищет совпадение с указанной строкой во всех файлах проекта. Это очень удобная команда для быстрого анализа из терминала. Она удобнее обычного grep, так как знает про игнорирование и не смотрит в директорию
git grep -i hexlet

git grep line

INFO.md:new line

# Флаг i позволяет искать без учета регистра
git grep -i hexlet

README.md:Hello, Hexlet! How are you?

# Поиск в конкретном коммите
git grep Hexlet 5120bea

# Поиск по всей истории
# rev-list возвращает список хешей коммитов
git grep Hexlet $(git rev-list --all)


#######################


# Выполняем очистку удаление пустых директорий которые попали в индекс
# -f – force, -d – directory
git clean -fd

# отмена изменений в файлах
git restore info.md


# восстанавливаем из git удаленный файл на локальном пепозитории
git restore PEOPLE.md

# git diff проверить изменения (перемещение: f b u выход: q) ++ добавили -- удалили
git diff

# Выведет все изменения, сделанные в рабочей директории
# которые были добавлены в индекс
git diff --staged

# git log анализ истории коммитов
git log

# У команды git log есть полезный флаг -p, который сразу выводит diff для каждого коммита:
git log -p #аналог diff

# просмотр коммита
git show 5120bea

###################

gti revert #отмена коммитов

# Этой команде нужен идентификатор коммита
# Это коммит, которым мы удалили файл PEOPLE.md
git revert aa600a43cb164408e4ad87d216bc679d097f1a6c
# После этой команды откроется редактор, ожидающий ввода описания коммита
# Обычно сообщение revert не меняют, поэтому достаточно просто закрыть редактор

######



Крайне часто разработчики делают коммит и сразу понимают, что забыли добавить часть файлов через git add. Оставшуюся часть изменений можно дослать следующим коммитом либо, если изменения еще не были отправлены во внешнюю систему, можно добавить изменения в текущий коммит. Для этого во время коммита добавляется флаг --amend:


# Увидели, что забыли добавить файл. Добавляем

git add README.md
git commit --amend

# Чтобы не открывался редактор для ввода описания коммита к команде git commit --amend можно добавить опцию --no-edit. В этом случае описание коммита не изменится.

#######




# Получение изменений с GitHub
# Разработчики не только отправляют изменения на GitHub, но и забирают изменения оттуда. Чаще всего это изменения, сделанные другими разработчиками проекта, но необязательно. Бывает такое, что один разработчик работает над одним проектом с разных компьютеров, на каждом из которых своя собственная копия репозитория (git работает только так). В таком случае, перед началом работы нужно всегда выполнять команду git pull --rebase, которая скачивает из внешнего репозитория новые коммиты и добавляет их в локальный репозиторий.

# Обычно, в статьях пишут, что достаточно вызывать git pull, но это может приводить к созданию ненужных merge-коммитов, ухудшающих историю изменений. Правильная работа с git pull требует знания таких вещей, как ветвление и git rebase. Они довольно сложны для новичков и рассматриваются позже, когда появится хоть какой-то опыт работы с git.


#В рабочей директории уже есть изменения, сохраните их с помощью git stash.
# переходим в рабочую папку И смотрим статус И упаковывае файлы в stash И смотрим статус
cd code-user/ && git status && git stash && git status

####
# Флаг -a автоматически добавляет все изменения рабочей директории в индекс
git commit -am 'do something'
###



# Показывает сокращенный вывод коммитов
git log --oneline

визуальный вывод
git log --graph

# HEAD~1 означает: взять голову и удалить, начиная от нее, один коммит
# То есть только последний коммит
git reset --hard HEAD~1
# То есть удалить 3 последних коммита
git reset --hard HEAD~3


######
# В этом файле можно оставлять комментарии
# Имя файла .gitignore
# Файл нужно создать самостоятельно

# Каждая строчка — это шаблон, по которому происходит игнорирование

# Игнорируется файл в любой директории проекта
access.log

# Игнорируется директория в любой директории проекта
node_modules/

# Игнорируется каталог в корне рабочей директории
/coverage/

# Игнорируются все файлы с расширением sqlite3 в директории db,
# но не игнорируются такие же файлы внутри любого вложенного каталога в db
# например, /db/something/lala.sqlite3
/db/*.sqlite3

# игнорировать все .txt файлы в каталоге doc/
# на всех уровнях вложенности
doc/**/*.txt



#####

# git stash прячем все файлы которые хотели закоменить но не успели потому что надо сделать срочный коммент другова файла.
git stash

# создаем и сохраняем файл с любым содржимым 
echo "Создайте файл todo.md с любым содержимым" > todo.md 

# проверяем файл на внутреннее наполнение
cat todo.md


#дополняем в файл строчку (дописываем не перезаписывая файл >> )
echo "stash не трогает новые файлы, которые еще не добавлены в индекс." >> hexlet.txt

# проверяем файл на внутреннее наполнение
cat hexlet.txt

# проверяем статус до исполнения
git status

# делаем коммит только с файлом hexlet.txt
git add hexlet.txt && git commit -m "hexlet.txt"

# проверяем статус после исполнения
git status

## восстанавливаем то что было упаковано в stash
git stash pop




https://www.youtube.com/watch?v=qlBJ4TmXVmg
